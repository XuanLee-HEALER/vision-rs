import LearnLayout from '@/components/LearnLayout';
import TaskScheduling from '@/components/tokio/TaskScheduling';

export const metadata = {
  title: 'Tokio 任务调度',
  description: '工作窃取算法详解',
};

<LearnLayout>

# 任务调度

Tokio 使用工作窃取算法实现高效的任务调度。

## 工作窃取算法

<TaskScheduling />

### 原理

- **本地优先**：线程优先执行自己的任务
- **队尾窃取**：空闲线程从繁忙线程队尾窃取
- **减少竞争**：双端队列，两端操作

### 优势

✓ **负载均衡**：自动平衡各线程任务✓ **缓存友好**：优先本地任务✓
**低开销**：减少锁竞争

## spawn vs spawn_blocking

### spawn (异步任务)

```rust
tokio::spawn(async {
    // 异步操作，不阻塞线程
    let data = fetch_from_network().await;
    println!("Data: {}", data);
});
```text

### spawn_blocking (阻塞任务)

```rust
tokio::task::spawn_blocking(|| {
    // CPU 密集或阻塞操作
    expensive_computation()
});
```text

**区别**：

- `spawn`：运行在 Worker 线程，不应阻塞
- `spawn_blocking`：运行在独立线程池，可以阻塞

## Task优先级

Tokio 使用 LIFO 策略处理本地任务：

```rust
// 新任务被添加到队列头部
tokio::spawn(async { /* Task 1 */ });
tokio::spawn(async { /* Task 2 */ });  // 会先执行
```text

## Yield

主动让出 CPU：

```rust
async fn cooperative_task() {
    for i in 0..1000 {
        // 执行工作
        do_work(i);

        // 每 100 次迭代让出一次
        if i % 100 == 0 {
            tokio::task::yield_now().await;
        }
    }
}
```text

## 小结

- ✅ 工作窃取实现负载均衡
- ✅ 区分异步和阻塞任务
- ✅ 高效利用多核 CPU
- ✅ 支持主动让出 CPU

</LearnLayout>

export default ({ children }) => <>{children}</>;
