import LearnLayout from '@/components/LearnLayout';
import ReactorPattern from '@/components/tokio/ReactorPattern';

export const metadata = {
  title: 'Reactor 模式',
  description: 'Tokio 的 I/O 事件处理机制',
};

<LearnLayout>

# Reactor 模式

Reactor 是 Tokio 处理 I/O 事件的核心组件，基于 mio 库实现。

## 架构

<ReactorPattern />

### 组件

- **Event Loop**：持续监听 I/O 事件
- **Reactor**：基于 mio，使用 epoll/kqueue/IOCP
- **Waker**：唤醒等待的 Future

## I/O 注册

```rust
use tokio::net::TcpStream;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 连接操作
    let stream = TcpStream::connect("127.0.0.1:8080").await?;

    // 底层流程：
    // 1. 创建 socket，设置非阻塞
    // 2. 注册到 Reactor（epoll_ctl）
    // 3. 返回 Pending，保存 Waker
    // 4. I/O 就绪时，Reactor 唤醒任务
    // 5. 再次 poll，返回 Ready

    Ok(())
}
```text

## Waker 机制

### 工作流程

```rust
impl Future for MyFuture {
    type Output = ();

    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<()> {
        if self.is_ready() {
            Poll::Ready(())
        } else {
            // 保存 Waker，等待 I/O 事件唤醒
            self.waker = Some(cx.waker().clone());
            Poll::Pending
        }
    }
}

// I/O 就绪时，Reactor 调用
waker.wake();  // 唤醒任务，重新 poll
```text

## mio 集成

### 平台差异

| 平台      | I/O 多路复用 |
| --------- | ------------ |
| Linux     | **epoll**    |
| macOS/BSD | **kqueue**   |
| Windows   | **IOCP**     |

### mio 示例

```rust
use mio::{Events, Interest, Poll, Token};
use mio::net::TcpListener;

fn main() -> std::io::Result<()> {
    let mut poll = Poll::new()?;
    let mut events = Events::with_capacity(128);

    let mut listener = TcpListener::bind("127.0.0.1:9000".parse().unwrap())?;

    poll.registry().register(
        &mut listener,
        Token(0),
        Interest::READABLE,
    )?;

    loop {
        poll.poll(&mut events, None)?;

        for event in events.iter() {
            match event.token() {
                Token(0) => {
                    // Accept connections
                    let (connection, address) = listener.accept()?;
                    println!("New connection from {:?}", address);
                }
                _ => {}
            }
        }
    }
}
```text

## 性能特性

### 零拷贝

Tokio 支持零拷贝 I/O：

```rust
use tokio::fs::File;
use tokio::net::TcpStream;

async fn send_file(socket: &mut TcpStream) -> io::Result<()> {
    let file = File::open("large_file.dat").await?;

    // 零拷贝传输（使用 sendfile 系统调用）
    tokio::io::copy(&mut file, socket).await?;
    Ok(())
}
```text

### 批量处理

Reactor 一次 poll 可以处理多个就绪事件：

```rust
// 伪代码
loop {
    let events = epoll_wait();  // 一次获取多个事件

    for event in events {
        // 批量处理，提高效率
        handle_event(event);
    }
}
```text

## 实践建议

### ✅ 推荐做法

```rust
// 1. 使用异步 I/O
async fn read_file() -> io::Result<String> {
    tokio::fs::read_to_string("file.txt").await
}

// 2. 正确处理错误
async fn safe_connect() -> Result<TcpStream, io::Error> {
    match TcpStream::connect("127.0.0.1:8080").await {
        Ok(stream) => Ok(stream),
        Err(e) => {
            eprintln!("Connection failed: {}", e);
            Err(e)
        }
    }
}
```text

### ❌ 避免做法

```rust
// ❌ 不要混用阻塞 I/O
async fn bad_example() {
    // 这会阻塞 worker 线程！
    let data = std::fs::read_to_string("file.txt").unwrap();
}

// ✅ 应该使用
async fn good_example() {
    let data = tokio::fs::read_to_string("file.txt").await.unwrap();
}
```text

## 小结

- ✅ Reactor 监听 I/O 事件
- ✅ Waker 唤醒等待的任务
- ✅ 基于 mio，跨平台支持
- ✅ 零拷贝，高性能
- ✅ 批量处理事件

</LearnLayout>

export default ({ children }) => <>{children}</>;
