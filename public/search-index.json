[
  {
    "slug": "learn/data-structures",
    "title": "数据结构 - Vision-RS",
    "description": "数据结构是性能与可维护性之间的共同语言。在 Rust 中，数据结构不仅是算法载体，更与所有权、借用、内存布局、可变性边界深度绑定",
    "category": "data-structures",
    "content": "数据结构\n\n数据结构是性能与可维护性之间的共同语言。在 Rust 中，数据结构不仅是算法载体，更与所有权、借用、内存布局、可变性边界深度绑定：很多\"写法限制\"其实就是\"结构不变式\"的护栏。\n\n本章节的定位是：以工程视角建立\"结构—代价—语义\"的长期映射。\n\n- 关注结构在内存中的布局与生命周期边界，而不仅是接口\n- 关注可变性与共享方式（独占/共享、内部可变性）的实现代价\n- 关注在真实项目中如何选择结构来匹配吞吐、延迟与可维护性目标\n\n在这里，你会更频繁地看到\"为什么选择这种结构\"而不是\"怎么把代码跑起来\"。最终目标是让你能在面对具体场景时，做出可解释、可复用的结构选择。\n\n> 阅读预期：读完本章节，你应该能为关键数据结构的选型写出可审计的理由，而不是凭经验拍脑袋。\n\n鸣谢\n\n感谢算法与系统领域的经典理论积累，也感谢 Rust 社区围绕内存布局、unsafe 封装与性能边界形成的工程共识与实践样本。",
    "headings": [
      "鸣谢"
    ]
  },
  {
    "slug": "learn/distributed-systems",
    "title": "分布式系统 - Vision-RS",
    "description": "分布式系统是",
    "category": "distributed-systems",
    "content": "分布式系统\n\n分布式系统是\"在不确定性中建立确定性\"的工程。它要求你处理网络分区、时钟偏差、部分失败、重复执行、状态收敛等问题——这些问题不会因为语言安全就自动消失，但 Rust 能让你把关键的不变式与资源边界更明确地表达出来，减少\"隐式共享\"和\"不可控副作用\"。\n\n本章节将以\"机制优先\"的方式组织内容：\n\n- 一致性与复制：日志、状态机、选主、仲裁、收敛路径\n- 可靠性与可运维性：幂等、重试、超时、补偿、观测与回放\n- 工程权衡：CAP/PACELC 的现实语境下如何做取舍与分层\n\n这里强调\"可解释的系统行为\"：你不仅要让系统工作，还要能回答它在异常情况下会怎样、为什么这样。\n\n> 阅读预期：读完本章节，你应该能把分布式问题拆成明确的机制与边界，并能落在代码与运行策略上。\n\n鸣谢\n\n感谢分布式系统领域的经典论文与实践系统（数据库、共识、消息系统、存储系统）的长期经验积累；也感谢 Rust 社区在可靠系统、异步与并发基础设施方面的持续投入。",
    "headings": [
      "鸣谢"
    ]
  },
  {
    "slug": "learn/network-protocols",
    "title": "网络协议 - Vision-RS",
    "description": "网络协议的本质是：在不可靠的媒介上建立可组合的",
    "category": "network-protocols",
    "content": "网络协议\n\n网络协议的本质是：在不可靠的媒介上建立可组合的\"语义层\"。Rust 在网络开发中的优势并不只是\"快\"，更在于它能用类型与边界管理，把连接生命周期、缓冲区管理、并发访问、资源回收这类传统高风险区域变得可验证、可维护。\n\n本章节关注三个层次的视角：\n\n- 协议本身的语义与演进：分层的意义、边界在哪里、如何组合\n- 实现层的关键问题：缓冲区、零拷贝倾向、背压、超时、取消、资源释放\n- 工程落地：可观测性与调试、故障注入、性能与可靠性的权衡\n\n你将看到网络协议不是\"背概念\"，而是一套工程约束体系：它要求你同时理解数据流、控制流和生命周期，并能在代码里把这些约束写出来。\n\n> 阅读预期：读完本章节，你应该能从协议语义推导出实现策略，而不是只会堆库与配置。\n\n鸣谢\n\n感谢 RFC、经典协议文档与众多实现者的长期贡献；也感谢社区在高性能网络、异步 I/O 与可观测性方面的工程沉淀，让这些知识可以被系统性复用。",
    "headings": [
      "鸣谢"
    ]
  },
  {
    "slug": "learn/rust-philosophy",
    "title": "Rust 设计哲学 - Vision-RS",
    "description": "Rust 的设计哲学围绕一个核心目标：在不牺牲性能的前提下，把",
    "category": "rust-philosophy",
    "content": "Rust 设计哲学\n\nRust 的设计哲学围绕一个核心目标：在不牺牲性能的前提下，把\"正确性\"尽可能前置到编译期。它不追求隐藏复杂度，而是用类型系统与编译器约束，把内存安全、并发安全、资源管理等系统级问题变成可被验证的工程事实。\n\n本章节聚焦语言层面的\"规则与代价\"：\n\n- 所有权 / 生命周期：资源与引用的可验证边界，决定了可用的表达方式与抽象形态\n- 零成本抽象：把高层表达折叠成底层等价物，让\"写得高级\"和\"跑得快\"同时成立\n- 内存安全 / 无 GC：不是独立主题，而是所有权模型与借用规则的\"结果与目标\"\n- 错误处理：以类型承载分支与恢复路径，减少隐式控制流\n- 并发 vs 异步：并发是一种组织方式；异步是延迟与调度的一种手段——两者重叠但不等价\n\n这里的重点不是\"怎么用\"，而是\"为什么这样设计、代价是什么、换来了什么\"。你会看到 Rust 的很多语法与限制，本质上都是在为\"可预测的系统行为\"付费。\n\n> 阅读预期：本章节适合在你写大型 Rust 项目之前先完成一轮通读，以便后续遇到 borrow\n> checker / trait bounds / async 约束时能快速定位根因。\n\n鸣谢\n\n感谢 Rust 官方团队、RFC 作者与编译器/标准库贡献者长期迭代语言模型与工具链；也感谢社区对所有权与异步模型的长期讨论与实践沉淀，使这些理念可以被工程化地传播与复用。",
    "headings": [
      "鸣谢"
    ]
  },
  {
    "slug": "learn/rust-stdlib",
    "title": "Rust 标准库 - Vision-RS",
    "description": "标准库是 Rust 语言哲学的工程化落地：它不仅提供 API，更体现了",
    "category": "rust-stdlib",
    "content": "Rust 标准库\n\n标准库是 Rust 语言哲学的工程化落地：它不仅提供 API，更体现了\"分层、边界、可移植性、性能与安全\"的取舍。理解标准库的结构和关键实现，有助于你在系统开发中做出更稳健的抽象与架构选择。\n\n本章节主要关注三个方向：\n\n- 分层结构：core / alloc / std\n  的职责边界与依赖方向，解释 Rust 如何同时覆盖嵌入式与通用操作系统环境\n- 内存管理主线：分配、Drop、引用计数、所有权转移在标准库中的具体落点（强调机制而非\"怎么调用 API\"）\n- 并发原语主线：互斥、读写锁、原子操作的语义与实现边界，理解线程安全的最小构件\n\n本章节刻意弱化 I/O 的精读：I/O 子系统往往更依赖 OS 与平台差异，适合在你构建网络/存储系统时按需深入；而标准库分层、内存、并发原语则更像\"地基\"，值得提前深挖并建立长期记忆。\n\n> 阅读预期：读完本章节，你应该能够回答：\"我现在写的这段 Rust 代码，在标准库层面到底依赖了什么？它的边界与代价是什么？\"\n\n鸣谢\n\n感谢标准库团队在稳定性与演进之间保持长期克制；也感谢众多性能与正确性相关的贡献者，使标准库在可维护性和工程强度上保持高水位。",
    "headings": [
      "鸣谢"
    ]
  },
  {
    "slug": "learn/third-party-libs",
    "title": "第三方库解析 - Vision-RS",
    "description": "Rust 生态的强项在于：许多核心能力并不强行塞进标准库，而是通过高质量第三方库先行探索",
    "category": "third-party-libs",
    "content": "第三方库解析\n\nRust 生态的强项在于：许多核心能力并不强行塞进标准库，而是通过高质量第三方库先行探索，再由实践反哺语言与工具链。理解这些库的设计理念与实现机制，能帮助你在架构层面做出正确选型，并避免\"只会用，不会解释\"的黑箱状态。\n\n本章节将把第三方库当作\"范式样本\"来解剖：\n\n- Tokio：异步运行时的调度与 I/O 模型，如何把 Future 推进到完成，以及工程上的可观测性与可控性\n- Serde：序列化框架如何利用类型系统与宏生成实现\"静态绑定 + 高性能\"的数据转换\n- std::future / Future 生态：Future\n  trait 的语义边界与运行时解耦方式，解释生态为何能并存多运行时\n\n这部分的目标不是列清单，而是梳理\"生态为何这样形成、库为何这样分层、这些选择对项目意味着什么\"。\n\n> 阅读预期：读完本章节，你应该能把\"异步/序列化\"从功能点提升为架构层能力：知道它们的边界、风险与性能模型。\n\n鸣谢\n\n感谢 Tokio 与 Serde 等核心库维护者持续投入，也感谢 Rust 社区对异步模型、宏与类型系统边界的长期打磨与讨论。",
    "headings": [
      "鸣谢"
    ]
  }
]